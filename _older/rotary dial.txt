Like them and are cheap. For Arduino used the following code based on what can be found athttp://www.buxtronix.net/2011/10/rotary-encoders-done-properly.html Please not it includes a correction in the table as could be found in one of the comments. That is essential. Also connect the 5V, essential as well: #define ROTARY_PIN1a 9 // DT #define ROTARY_PIN1b 10 //CLK // algorithm constants #define DIR_CCW 0x10 #define DIR_CW 0x20 // Use the full-step state table (emits a code at 00 only) const unsigned char ttable[7][4] = { {0x00, 0x02, 0x04, 0x00}, {0x03, 0x00, 0x01, 0x10}, {0x03, 0x02, 0x00, 0x00}, {0x03, 0x02, 0x01, 0x00}, {0x06, 0x00, 0x04, 0x00}, {0x06, 0x05, 0x00, 0x20}, {0x06, 0x05, 0x04, 0x00}, }; /* Read input pins and process for events. Call this either from a * loop or an interrupt (eg pin change or timer). * * Returns 0 on no event, otherwise 0x20 or 0x10 depending on the direction. */ unsigned char rotary_process1() { unsigned char pinstate = (digitalRead(ROTARY_PIN1b) << 1) | digitalRead(ROTARY_PIN1a); state1 = ttable[state1 & 0xf][pinstate]; return (state1 & 0x30); } volatile unsigned char state1 = 0; int rot1 = 0; // ------------------------ In setup(): pinMode(ROTARY_PIN1a, INPUT); pinMode(ROTARY_PIN1b, INPUT); // ------------------------ In loop() rot_result = rotary_process1(); if (rot_result) { rot1 += (rot_result == DIR_CCW ? -1 : 1); }


<http://www.banggood.com/5Pcs-5V-KY-040-Rotary-Encoder-Module-For-Arduino-AVR-PIC-p-951151.html>